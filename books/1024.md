# 解释器风格

## 特征

- 基于解释器风格的系统核心在于虚拟机。
- 一个基于解释器风格的系统通常包括：正在被解释执行的伪码和解释引擎
- 伪码：由需要被解释执行的源代码和解释引擎分析所得的中间代码组成
- 解释引擎包括：语法解释器和解释器当前的运行状态

- 图示

  - 

    ![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221172444.png)

    

## 优点

  - 在文法规则比较简单的情况下，解释器风格工作的很好
  - 易于改变和扩展文法
    - 因为解释器风格使用类来表示文法规则，用户可以使用继承来改变和扩展文法。已有的表达式可以采用增量的方式逐渐扩充，而新的表达式可以定义为旧表达式的变体
  - 易于实现文法。
  - 可以用多种操作来“解释”一个句子。

## 缺点

  - 无法解释复杂的文法规则
    - 对于比较简单的文法规则，解释器风格工作的很好，而对于复杂的文法规则，则由于文法层次的庞大而难于管理

  - 应用范围比较狭窄

  - 在文法规则比较复杂，则文法的层次变得无法管理，系统中需要包含许多表示文法规则的类

##  解释器风格实例

### 实例1

一个布尔表达式解释器

- 目标：布尔表达式求值系统  现定义由如下文法定义的布尔正则表达式

  ![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221175542.png)

  系统的体系结构可以随技术的发展而发生变化

  + 传统的编译器模型

  + ![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221175812.png)

  + 具有共享符号表的传统编译器模型

  + ![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221175830.png)

  + 随着时间的推移，编译技术变得更加复杂，更多的注意力转移到程序在编译过程的中间表示，例如属性文法树--典型的现代编译器模型

  + ![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221175900.png)

    

  布尔表达式求值系统类图 ，如下图所示：

  ![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221175930.png)

  布尔表达式抽象语法树实例，如下图所示： 

  

  ![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221175947.png)

  

  - 布尔表达式求值系统的优缺点

    - 在文法规则比较简单的情况下，解释器风格工作的很好，但如果文法规则复杂，则文法的层次变得庞大而无法管理，系统中需要包含许多表示文法规则的类。
    - 最高效的解释器通常不是通过直接解释语法分析数实现的，而是首先将它们转换成另一种形式。
    - 易于改变和扩展文法。
    - 易于实现文法。

  - 布尔表达式求值系统中的角色

    - BooleanExpression（抽象布尔表达式）
    - TerminalExpression（终结符表达式，如VariableExpresssion和Constant）
    - NonterminalExpression（非终结符表达式，如AndExpression、OrExpression和NotExpression）
    - Context（上下文，也就是“解释引擎内部状态”）
    - Client（客户）

  - 布尔表达式求值系统的实现

    - 在具体实现布尔表达式求值系统时还有许多细节的问题要处理，这些细节问题处理的好坏甚至会直接影响整个系统的性能。这些问题主要表现在以下几个方面
      - 创建抽象语法树
      - 定义求值操作
      - 共享终结符

### 实例2

    解释器风格定义了特定语言的文法表示和解释该文法的解释器。这种模式如同乐谱。其中，音阶和它的持续时间可以用五线谱上的符号表示。这些符号就是音乐语言。音乐家按照乐谱演奏，就可以反复重现同样的音乐。 

![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221180148.png)

### 实例3

罗马数字转换系统

![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221180228.png)

### 实例4

```
Javascript 语言解释器JlBrowers
1. 词法分析
      以嵌入在html文本中的JS脚本程序为输入形成单词链表，以便语法分析。单词链表为双向链表。
 
2. 语法分析
      以单链表为输入，依JS语言的语法规则形成中间数据结构。中间数据结构能够反映出程序语句描述的数据处理流程。
 
3. 解释执行器
     以中间数据结构为输入负责对语句解释执行的控制。
 
4. 语句解释器
       完成各类型控制语句的解释执行，该模块可能会调用解释执行器而形成递归调用。
       
5. 表达式规约器
      由语句解释器来调用，它负责在语句解释执行过程中完成各类型表达式的运算和赋值语句的执行。
 
6. 与浏览器交互
       完成在表达式运算过程中对当前文档对象和html 文本中各种控件对象的属性值的修改并通过改变浏览器的输出显示表现出来。


```

Javascript 语言解释器JlBrowers模块图![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221180311.png)

```
AbstractExpression  (Expression) 
声明执行特定操作的接口。
TerminalExpression  ( ThousandExpression, HundredExpression, TenExpression, OneExpression ) 
实现一个与语法中终结符相关的解释操作。 
句子中的每一个终结符都需要一个实例。
NonterminalExpression  
语法中的每个规则R ::= R1R2...Rn 都需要这样的一个类。
管理从R1到Rn每一个符号的AbstractExpression类型变量的实例。
实现语法中非终结符的解释操作，在解释中可能需要递归调用自身。
Context  (Context) 
包含对于解释器来说是全局的信息。
Client  (InterpreterApp) 
建立（或者给定）一个抽象语法树。抽象语法树是由NonterminalExpression 和TerminalExpression类的实例组合而成。
调用解释操作。


```

