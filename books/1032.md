# 基于UML的软件体系结构描述

## UML简介

### UML的概念

- UML(Unified Modeling Language)是一种统一建模语言，下面对它进行解释。
  - 统一Unified
    - 表示是一种通用的标准，它被OMG(Object Management Group)认可，成为软件工业界的一种标准。
    - UML表述的内容能被各类人员所理解，包括客户、领域专家、分析师、设计师、程序员、测试工程师及培训人员等。
    - 他们可以通过UML充分理解和表达自己所关注的那部分内容。
  - 建模Modeling
    - 即建立软件系统的模型。
    - 为说明建模的价值，Booch给出一个类比：盖一个宠物窝棚、修一个乡间别墅和建一座摩天大楼。
    - 建立一个简单的系统，例如盖一个宠物窝棚，模型可有可无；建立一个比较复杂的系统，例如修一个乡间别墅，模型的必要性增大；建立一个高度复杂的系统，例如建一座摩天大楼，模型必不可少。
  - 语言Language
    - 表明它是一套按照特定规则和模式组成的符号系统，它用半形式化方法定义，即用图形符号、自然语言和形式语言相结合的方法来描述定义的。

- UML(Unified Modeling Language)是下面这些最好的建模方法中最好部分的集成:

  - 商务流程模型(Work Flow)
  - 对象建模方法
  - 软构件建模思想

- UML是一种用可视化方法对软件系统进行描述、实施和说明的标准语言。

- 支持用不同实现技术进行的软件开发全过程。

### UML的发展历史

![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221202206.png)

  - 公认的面向对象建模语言出现于20世纪70年代中期，到了80年代末发展极为迅速。
  - 据统计，1989年到1994年，面向对象建模语言的数量从不到10种增加到50多种。
  - 各位语言的创造者极力推崇自己的语言，并不断地发展完善它。
  - 但由于各种建模语言所固有的差异和优缺点，使得使用者不知道该选用哪种语言。
  - 其中比较流行的有Booch、Rumbaugh(OMT)、Jacobsom(OOSE)、Coad-Yourdon等方法。OMT擅长分析，Booch擅长设计，OOSE擅长业务建模。
  - Rumbaugh于1994年离开GE加入Booch所在的Rational公司，他们一起研究一种统一的方法，一年后，Unified Method 0.8诞生，同年，Rational收购了Jacobson所在的Objectory AB公司。经过三年的共同努力，UML0.9和UML0.91于1996年相继面世。
  - 此后，UML的创始人Booch等邀请计算机软件工程界的著名人士和著名的企业如IBM、HP、DEC、Microsoft、Oracle等对UML进行评论，提出修改意见。1997年1月，Rational公司向OMG递交了UML1.0标准文本。1997年11月，OMG宣布接受UML，认定为标准的建模语言。UML目前还在不断发展和完善。

  

  ![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221202230.png)

  

  

  

## UML基本图符

![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221202251.png)

- UML包含了一些图形元素，在进行系统分析和设计时需要这些图。

- UML通过提供这些图，使得可以通过多个视图从不同角度来描述一个系统。

### 1.用例图

  Use Case Diagram

  - 用例(Use Case)是从**用户的观点对系统行为的一个描述**。

  - 它从用户角度搜集系统需求，这样既可靠又不易遗漏需求。 这里先举一个简单的例子，假设一个人使用洗衣机来洗衣服，用UML用例图来描述洗衣过程

  - - ![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221210544.png)

    - 其中，小人表示参与者(Actor)，它代表拟建系统外部和系统进行交互的某类人或系统；椭圆代表用例。用例定义一组相关的由系统执行的动作序列。 

### 2.类图

  Class Diagram

  - 一个类是一组具有类似属性和共同行为的事物。

  - 例如，属于洗衣机类的事物都有诸如品牌(Brand Name)、型号(Model Name)、序列号(Serial Number)和容量(Capacity)等属性，它们的行为包括加衣物(Add Clothes)、加洗涤剂(Add Detergent)、取出衣物(Remove Clothes)等操作。

      - 下图是一个用UML表示法表示的洗衣机属性和行为的例子。
        - ![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221210648.png)

      - 矩形方框是UML中表示类的图标，它被分为3个区域：最上面是类名，中间是属性，最下面是操作。类图由这些类框和表明类之间关联的连线所组成。

### 3.对象图

  Object Diagram

  - 对象是一个类的实例，是具有具体属性和行为的一个具体事物。

  - 如洗衣机品牌为海尔或小天鹅，一次最多洗涤重量为5 kg。

      - 图说明了如何用UML来表示对象。
        - ![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221210737.png)

  - 使用UML描述对象时和类图类似，但在对象名下要加下划线，对象名后加冒号加类名。 

### 4.顺序图

  Sequence Diagram

  - 类图和对象图表达的是系统的静态结构。

  - 在一个运行的系统中，对象之间要发生交互，并且这些交互要经历一定的时间。UML顺序图所表达的正是这种基于时间的动态交互。

  - 仍以洗衣机为例，洗衣机的构件包括一个注水的进水管(Water Pipe)、一个用来装衣物的洗涤缸(Drum)和一个排水管(Drain)。这些构件也是对象

      - 当“洗衣服”这个用例被执行时，假设已完成了“加衣物”、“加洗涤剂”和“开机”操作，那么应执行以下步骤：

        - (1) 通过进水管向洗涤缸中注水。
        - (2) 洗涤缸保持静止状态。
        - (3) 水注满，停止注水。
        - (4) 洗涤缸往返旋转15分钟。
        - (5) 通过排水管排掉洗涤后的脏水。
        - (6) 重新开始注水。
        - (7) 洗涤缸继续往返旋转洗涤。
        - (8) 停止向洗衣机中注水。
        - (9) 通过排水管排掉漂洗衣物的水。
        - (10) 洗涤缸加快速度单方向旋转5分钟。
        - (11) 洗涤缸停止旋转，洗衣过程结束。

      - 下图用一个顺序图说明了进水管、洗涤缸和排水管(由顺序图顶端的矩形图标代表)之间随时间变化所经历的交互过程。

        ![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221210921.png)

        

  - 对象符号下方垂直的虚线，称为对象生存线。沿对象生存线上展开的细长矩形称为激活，表示该对象正在执行某个操作，矩形的长度表示执行操作的持续时间。

  - 带箭头的水平实线表示发送消息，消息可以发往其他对象或自身对象。图中对象之间发送的消息有6个，发往自身的消息有5个。 消息可以是简单的(Simple)、同步的(Synchronous)或异步的(Asynchronous)。消息的图符可以用下图来表示。

    ![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221210949.png)

    <center>顺序图的消息图符</center>

    

### 5.协作图

  Collaboration Diagram

  - 系统的工作目标是由系统中各组成元素相互协作完成的，建模语言必须具备这种协作关系的表达方式。UML协作图就是为此目的设计的。

  - 下图是协作图的一个例子。

    ![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221211143.png)

    

      - 该图仍以洗衣机为例，在洗衣机构件的类集中又增加了一个内部计时器(Internal Timer)。在经过一段时间后，内部计时器控制进水管停止注水，然后启动洗涤缸往返旋转。图中的序号代表命令消息的发送顺序，内部计时器先向进水管对象发送停止注水消息，后向洗涤缸对象发送往返旋转消息。 

    

### 6.状态图

  Statechart Diagram

  - 在任一给定的时刻，一个对象总是处于某一特定的状态。
  - 状态在图中表述为圆角矩形，有两种比较特殊的状态：初始状态(实心圆点)和结束状态(实心圆点外加一个圆圈)。只能有一个初始状态，可能有多种结束状态。

  - 一个人可以是新生儿、婴儿、儿童、少年、青年、中年或老年。一个电梯可以处于上升、下降或停止状态。一台洗衣机可处于浸泡(Soak)、洗涤(Wash)、漂洗(Rinse)、脱水(Spin)或关机(Off)状态。UML状态图如图所示，说明洗衣机可以从一个状态转移到另一个状态。

    ![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221211532.png)



### 7.活动图

​    Activity Diagram

  - 活动图类似于流程图，用于描述用例中的事件流结构。

  - 下图显示了顺序图中步骤4到步骤6之间按顺序的UML活动图。

    ![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221211625.png)

    

### 8.构件图

  Component Diagram

  - 构件图和下一个要介绍的部署图将不再使用洗衣机作为例子来做说明，因为它们和整个计算机系统密切相关。

  - 用下图来说明如何用UML表示软件构件。

    ![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221211734.png)

    

  - 构件是软件系统的一个物理单元，例如数据表、可执行文件、动态链接库、文档等。

    

### 9.部署图

  Deployment Diagram

  - 部署图显示了基于计算机系统的物理体系结构。

  - 它可以描述计算机和设备，展示它们之间的连接，以及驻留在每台机器中的软件。

  - 每台计算机用一个立方体来表示，立方体之间的连线表示这些计算机之间的通信关系。

    ![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221211818.png)

    

### 其他特征图

下面3种图都可以用来组织和扩展模型图的特征。

  - 包

    Package

    - 当需要将图中的组织元素分组，或者在图中说明一些类或构件是某个特定子系统的一部分时，可以将这些元素组织成包。

    - 包的表示法如图所示。

      ![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221211918.png)

  - 注释

    Note

    - 注释可以作为图中某部分的解释，其图标是一个带折角的矩形，矩形框中是解释性文字

      ![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221211949.png)

  - 构造型

    Stereotype

    - 构造型可以让用户能使用现有的UML元素来定制新的元素。

    - 构造型用双尖括号(Guillemets)括起来的一个名称来表示


## UML的静态建模机制

UML的静态建模机制包括用例图、类图、对象图、包、构件图和部署图。
    
### 用例图

用例模型Use Case Model
```
        - 用例模型描述的是外部角色(Actor)所理解的系统功能。 
        - 用例模型适用于需求分析阶段，它是经过系统开发者和用户反复讨论后而建立的，说明了开发者和用户对系统功能和需求规格达成的共识。
        - 用例模型描述了待开发系统的功能需求，它将系统看作黑盒，从系统的外部用户角度出发，对系统进行抽象表示。
        - 用例模型驱动了需求分析之后各阶段的开发工作，不仅在开发过程中保证了系统所有功能的实现，而且被用于测试系统是否满足用户的需求和验证系统的有效性，从而影响到开发工作的各个阶段和UML的各个模型。
        - 用例视图是其他视图的核心和基础，其他视图依靠用例视图中所描述的内容来构造。
        - 用例模型基本组成包括：用例、角色和系统。
        - 用例用于描述系统的功能，即从外部用户的角度观察系统应该支持的功能。
        - 用例宏观描述了系统功能，帮助分析人员理解系统的行为。
        - 每个系统中的用例都具体说明系统所具有的基本功能。
        - 角色是与系统进行交互的外部实体，可以是系统用户，也可以是与系统交互的任何其他系统或硬件设备。
        - 系统边界线以内的区域(即用例的活动区域)抽象表示系统能够实现的基本功能。
```
用例Use Case
```
        - 从本质上讲，一个用例是用户与计算机之间的一次典型交互作用。
        - 在UML中，用例被定义成系统执行的一系列动作，动作执行的结果能被指定角色察觉到。 　　
        - 用例的特点
          - 用例捕获某些用户可见的需求，实现一个具体的用户目标。
          - 用例由角色激活，并提供确切的值给角色。
          - 用例可大可小，但它必须是对一个具体的用户目标实现的完整描述。
```
角色Actor
```
        - 角色是与系统交互的人或事。
        - 所谓与系统交互，指的是角色向系统发送消息，从系统中接收消息，或是在系统中交换信息。只要使用用例，与系统互相交流的任何人或事都是角色。
        - 角色是一个群体概念，表示一类能使用某个功能的人或事，并不是指某个个体。一个具体的个体在系统中可以具有多种不同的角色。
        - 角色都有名字，它的名字反映了该角色的身份和行为，但是不能将角色的名字表示成角色的某个实例，或表示成角色所需完成的功能。
        - 角色与系统进行通信的收、发消息机制，类似于面向对象编程中的消息机制。
        - 角色是启动用例的前提条件。首先，角色发送消息给用例，当初始化用例后，用例再开始执行，在执行过程中该用例也可能向一个或多个角色发送消息。
```
用例之间的关系
    
扩展关系
```
          - 如果一个用例中加入一些新的动作后构成另一个用例，那么这两个用例之间的关系就是扩展关系
          - 后者通过集成前者的一些行为得来
          - 前者通常称为通用化用例，后者常称为扩展用例
          - 扩展用例可以根据需要有选择地集成通用化用例的部分行为
```
使用关系
```
          - 一个用例使用另一个用例时，这两个用例之间就构成了使用关系
          - 通常，可以把用例中相同的行为提取出来单独做成一个用例，这个用例称为抽象用例
          - 当某个用例使用该抽象用例时，就像这个用例包含了抽象用例的所有行为
```
### 类图、对象图和包
```
      - 类图
        - 在面向对象建模技术中，将客观世界的实体映射为对象，并归纳成类。
        - 类、对象和它们之间的关联是面向对象技术中最基本的元素。系统的类模型和对象模型描述了系统的结构。
        - 在UML中，类和对象模型分别由类图和对象图表示。
        - 类图表示类和类之间的静态关系。
        - 不同于数据模型，它不仅显示了信息的结构，同时还描述了系统的行为。
        - 类图是定义其他图的基础，状态图、协作图等在这个基础上进一步描述了系统其他方面的特性。
        - 类图是一种用类和它们之间的关系描述系统的图示。
```


```
      - 关系
        - 关联关系
          - 关联用于描述类与类之间的连接。
          - 因为对象是类的实例，所以类与类之间的关联也就是其对象之间的关联。
          - 虽然类与类之间有含义各不相同的多种连接方式，但外部表示形式相似，统称为关联。
          - 关联关系通常都是双向的，即关联的对象双方彼此都能与对方通信。
          - 也就是，当某两个类的对象之间存在要互相通信的关系时，这两个类之间就存在关联关系。
        - 泛化关系
          - 又称继承关系，是指一个类(称为一般元素、基类元素或父元素)的所有信息(属性和操作)能被另一个类(称为特殊元素或子元素)继承。
          - 继承某个类的类中不仅可以有属于自己的信息，而且还拥有被继承类中的信息。
          - 泛化的优点是通过把一般的公共信息放在基类元素中，使得在处理具体情况时只需定义该情况的特殊信息即可，公共信息则从通用元素中继承得来，从而增强了系统的灵活性、易维护性和可扩充性，大大缩短了系统的维护时间。
          - 具有泛化关系的两个类之间，继承通用类所有信息的具体类称为子类，被继承类称为父类。
          - 可以从父类中继承的信息有属性、操作和所有的关联关系。
```
```
      - 对象图
        - 类图表示类以及类和类之间的关系，对象图则表示在某一时刻这些类的实例之间的具体关系。
        - 由于对象是类的实例，因此，UML对象图中的概念与类图中的概念完全一致，对象图可以帮助理解一个比较复杂的类图，也可以用于显示类图中的对象在某一点的连接关系。
        - 对象的图示方法与类的图示方法几乎一样，主要差别在于对象的名字下面要加下划线
```
```
      - 包
        - 包是一种组合机制，把各种模型元素通过内在的语义连在一起成为一个整体，形成一个高内聚、低耦合的集合，UML中将这种分组机制称为包。
        - 构成包的模型元素称为包的内容。
        - 包通常用于对模型的组织管理，因此有时又将包称为子系统。
        - 模型元素的分组方法可以是任意的。
        - 在UML中，最有用和强调最多的分组原则是依赖。
        - 包图主要显示模型元素的包以及这些包之间的依赖关系，有时还显示包和包之间的继承关系和组成关系。
```

### 构件图和部署图

构件图和部署图显示系统实现的一些特性，包括源代码的静态结构和运行时刻的实现结构。构件图显示代码本身的结构，部署图显示系统运行时刻的结构。
```
      - 构件图
        - 构件图的表示法如图4-35所示。
        - 构件图显示系统构件之间的依赖关系，如下图所示。
        - 一般来说，系统构件就是一个实际文件，可以是源代码文件、二进制代码和可执行文件等，可以用来显示编译、链接或执行时构件之间的依赖关系。 
```
![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221213241.png)
```
      - 部署图
        - 部署图描述系统硬件的物理拓扑结构以及在此结构上执行的系统。
        - 部署图可以显示计算节点的拓扑结构和通信路径、节点上运行的系统构件、系统构件包含的逻辑单元(对象、类)等。部署图常常用于帮助理解分布式系统。
        - 节点和连接
          - 节点代表一个物理设备以及其上运行的系统。
          - 节点表示为一个立方体，节点名放在左上角。
          - 与类和对象一样，节点可以用于表示类型和实例。
          - 当用该符号表示实例时，需要名字下面有一条下划线。节点之间的连线表示系统之间进行交互的通信路径，称为连接。
          - 通信类型放在连接旁边的<< >>之间，表示所用的通信协议或网络类型。
        - 构件和界面
          - 在部署图中，构件代表可执行的物理代码模块，它在逻辑上与类图中的包或类对应。
          - 因此，部署图中显示运行时各个包或类在节点中的分布情况。
          - 在面向对象方法中，类和构件等元素并不是所有的属性和操作都对外可见。
          - 它们对外提供了可见操作和属性，称为类和构件的界面。
          - 界面表示为一头是小圆圈的直线。
        - 对象
          - 一个面向对象系统中可以运行很多对象。
          - 因为构件可以看做与包或类对应的物理代码模块，所以构件中应包含一些运行的对象。
          - 如图4-36所示的部署图中的对象与对象图中的对象表示法一致。
```
## UML的动态建模机制

  - 在面向对象技术中，对象间的交互是通过在对象间传递消息完成的。

  - 在UML的所有动态图(顺序图、协作图、状态图、活动图)中，消息被当作对象间的一种通信表示方式。

  - 一般情况下，当一个对象调用另一个对象中的操作时，即完成了一次消息传递。

  - 当操作执行后，控制便返回到调用者。

  - 对象通过相互间的通信(消息传递)进行合作，并在其生命周期中根据通信的结果不断改变自身的状态。

  - 在UML中，消息的图形表示是用带有箭头的线段将消息发送者和接收者联系起来，箭头的类型表示消息的类型。

    - 简单消息
      Simple Message

      - 表示普通的控制流。它描述控制是如何在对象间进行传递的，不考虑通信的具体细节。
      - 这种消息类型主要用于通信细节未知或不需要考虑通信细节的场合。

    - 同步消息
      Synchronous Message

      - 表示嵌套的控制流。操作的调用便是一种典型的同步消息。
      - 调用者发出消息后必须等待消息返回，只有当处理消息的操作执行完毕后，调用者才可继续执行自己的操作。

    - 异步消息
      Asynchronous Message

      - 表示异步控制流。调用者发出消息后不用等待消息的返回即可继续执行自己的操作。异步消息在实时系统中常用来描述其中的并发行为。

  - 顺序图

    - 顺序图用来描述对象间的动态交互关系，侧重体现对象间消息传递的时间顺序
    - 顺序图用横坐标轴表示对象，用纵坐标轴表示时间
    - 顺序图横坐标轴上的对象用一个带有垂直虚线的矩形框表示，矩形框中写有对象名和/或类名
    - 垂直虚线是对象的生命线，用于表示在某段时间内对象是否存在
    - 对象间的通信用对象的生命线之间的水平消息线来表示
    - 消息的箭头表示消息的类型，如同步消息、异步消息或简单消息
    - 　　如果收到消息，那么对象就立即开始执行活动，即对象被激活了。激活用对象生命线上的细长矩形框表示。消息可以用消息名称和参数来表示。消息可带有条件表达式，用以表示分支或决定是否发送消息。当条件表达式用于表示分支时，分支是互斥的，也就是说一次只能发送分支中的一个消息。
    - 　　顺序图的左边可以有注释，用以说明消息发送的时刻、描述动作的执行情况以及约束信息等。

  - 协作图

    - 协作图用于描述相互合作的对象间的交互和链接关系(链接是关联的实例化)。
    - 尽管顺序图和协作图都用来描述对象间的交互关系，但侧重点并不一样。顺序图强调交互的时间顺序，而协作图则强调交互对象间的静态链接关系。
    - 协作图表示对象与对象间的链接以及链接间如何发送消息。
    - 协作图中对象的外观与顺序图中的一样。
    - 对象间链接的表示方法类似于类图中的关联。
    - 通过链接上标以用消息串表示的消息(简单、异步或同步消息)来表达对象间的消息传递。
    - 链接
    - 消息流
      - 在协作图的链接线上，可通过用消息串表示的消息来描述对象间的交互
      - 消息串中包含了发送的消息、消息的参数、消息的返回值以及消息的序列号等信息。
    - 对象的生命周期
      - 如果一个对象在消息的交互中被创建，则可在对象名称之后标以{new}。
      - 类似地，如果一个对象在交互期间被删除，则可在对象名称之后标以{destroy}。

  - 状态图

    - 状态图描述一个特定对象的所有可能状态以及引起状态转移的事件。
    - 状态图由一系列状态和状态之间的转移构成，通过状态图可以表示单个对象在其生命周期中的行为。
    - 状态
      - 每个对象都具有状态，状态是对象执行某个活动的结果。
      - 当发生某些事情后，结果将引起对象的状态的变化。
      - 通常将这些引起对象状态变化的事情称为“事件”。
      - 状态图可以有一个起点(初态)和多个终点(终态)。
      - 状态图的起点用一个黑圆点来表示，终点用黑圆点外加一个圆表示，状态用一个圆角矩形表示。
    - 转移
      - 状态图中用状态间带箭头的连线来表示状态的转移
      - 状态的变化通常由事件触发，此时应在状态转移线上标出触发转移的事件表达式
      - 如果状态转移线上未标明事件，则表示在源状态的内部活动执行完毕后自动触发转移
      - 一般情况，状态图是对类图的补充
      - 实际上，并不需要为所有的类画状态图，仅需要为那些有多个状态且其行为受外界环境的影响而发生改变的类画状态图

  - 活动图

    - 活动图可以描述操作(类的方法)中完成的工作，也可以描述用例和对象内部的工作过程。
    - 活动图由状态图变化而来，但它们的目的有所不同。
    - 活动图的主要目的是描述动作(将要执行的工作或活动)以及对象状态变化的结果。
    - 在活动图中，当一个活动结束后将立即进入下一个活动。
    - 但在状态图中，状态的变迁可能需要由事件触发。
    - 活动和转移
      - 一项操作可以用一系列相关的活动来描述。
      - 活动只有一个起始点，但结束点可以有多个。
      - 一个活动可以顺序地跟在另一个活动之后，这是简单的顺序关系。
      - 如果在活动图中使用一个菱形的判断标志，则表达条件关系，判断标志可以有多个输入和输出转移，但在活动的运作中只触发其中的一个输出转移。
      - 活动图也可以表示并发行为。
      - 在活动图中，使用一个称为同步条的水平粗线可以将一条转移分为多个并发执行的分支，或将多个转移合为一条转移。
      - 此时，只有当输入的转移全部有效，同步条才会触发转移，进而执行后面的活动。
    - 泳道
      - 泳道用纵向矩形框表示，放在该矩形框内均属于某个泳道的所有活动；将对象和名称放在矩形框的顶部，表示该对象对泳道中的活动负责
      - 所以，通过泳道可以将活动图的逻辑描述与顺序图、协作图的责任描述结合起来。
    - 对象
      - 在活动图中可以出现对象。
      - 对象可以作为活动的输入或输出，也可以仅表示某一活动对对象的影响。
      - 如果对象是一个活动的输入，那么用一个从对象指向活动的虚线箭头表示；如果对象是一个活动的输出，那么用一个从活动指向对象的虚线箭头表示；如果仅表示对象受到某一活动的影响，则可用不带箭头的虚线来连接对象与活动。
    - 信号
      - 在活动图中可以表示信号的发送与接收，分别用发送符号和接收符号表示。
      - 发送符号和接收符号也可与消息的发送对象和消息的接收对象相连。

## UML在软件体系结构建模中的应用实例

下面以浏览器/服务器的软件体系结构为例子，用UML的建模机制对简单的B/S体系结构进行建模，并说明该结构的构件交互及其交互模式的重用技术。

### 1.用UML对构件交互模式进行静态建模

- 前面已经介绍UML的静态建模机制包括用例图、类图、对象图、包、构件图和部署图。在本节主要通过用例图和部署图两种图来对B/S体系结构进行静态建模

- 经过对B/S风格的软件体系结构的分析可知，用户通过浏览器与服务器端的交互用UML的部署图来表示，如图所示

  ![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221213925.png)

  <center>浏览器与服务器交互的部署图</center>

  - 浏览器是运行在客户端的应用程序，与网络上的服务器连接并请求获取信息页。
  - 当请求被满足，即浏览器得到所请求的信息页，连接就终止。
  - 浏览器指导怎样通过HTTP与Web服务器通信，以及怎样显示由Web服务器返回的格式化的信息(即以网页的形式返回)。
  - 服务器端的Web服务器接收网页(静态的HTML或服务器页)的请求，根据请求，Web服务器可能启动某个服务器端的处理(例如向数据库服务器发出SQL查询，然后将查询结果返回)，再将得到的信息以网页(如HTML格式的网页)的形式返回，在客户端的浏览器中显示出来。
  - 在B/S体系结构中，有各种构件和连接件。构件分为形成客户浏览器和服务器端的构件，服务器端构件包括Web服务器端和数据库服务器构件。
  - 构件在这里可以看做是进行一定运算或其他操作的体系结构的实体，而连接件是用于提供构件间交互的体系结构实体。通过构件和连接件加上由构件之间形成的交互，就形成了一个完整的体系结构。其中，构件间的信息交互有同步和异步两种；而内部构件的通信分为同步、异步、代理和组通信等。连接件不但表示一个简单的交互操作(例如过程调用、共享变量的使用)，而且还表示复杂的交互(例如TCP/IP协议、数据库使用协议、异步事件列表、网络安全协议等)。

- 用UML的静态建模机制与扩展机制的构造型对构件间交互进行静态建模，如图所示，其中<<构件>>、<<资源>>和<<连接件>>是构造型的。

  ![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221214033.png)

  <center>浏览器/服务器类图</center>

  - 　　构件用来描述终端客户的浏览器类和用于建立数据库连接并负责数据库存储和检索，响应请求数据查询、处理的服务器类。
  - 　　资源代表支持构件与连接件的通信，而Internet就是一种资源，使得浏览器的连接件可以通过网络与服务器建立连接。
  - 　　连接件可以表示简单的交互，也可以表示复杂的交互，它隐藏构件间的内部交互细节(例如同步或异步信息的传递)。从上图中描述可知，每一个服务器构件与浏览器端构件间是一对多关系，浏览器与浏览器连接件和服务器与服务器连接件都是一对一的关系，而网络资源与浏览器连接件、服务器连接件都是一对多的关系。

- 在B/S体系结构中，还可对连接件进一步细化为浏览器连接件和异步客户连接件。浏览器连接件也就是客户连接件，可以分为同步客户连接件和异步客户连接件。异步客户连接件是一个组合类，它由客户消息输入缓存类、客户请求端类和客户返回端类构成。用UML的类图表示如图4-43所示。

  ![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221214443.png)

  　　<center>客户连接件类图</center> 

- 服务器连接件可以分为单线程和多线程服务器连接件。用UML类图表示如图4-44所示。

  ![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221214555.png)

  　　<center>服务器连接件类图 </center> 

  

### 2.用UML对构件交互模式进行动态建模

- 如前面所讲，UML中动态图有顺序图、协作图、状态图、活动图。在本节中，主要利用协作图对B/S体系结构的构件之间的交互进行建模。

- 下图中显示了客户端浏览器与服务器端的构件的动态交互的协作图。 

  ![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221214827.png)

  <center>浏览器与服务器的协作图</center>

- 首先，用户通过浏览器向浏览器连接件发出消息请求，浏览器连接件将请求进行打包形成消息包(消息包中包含相应的服务参数)，再通过网络资源(例如传输协议软件)将消息包发给服务器连接件，服务器连接件接收器将消息包进行检查，如果无错，就将它提交给服务器，服务器根据请求包中的请求完成相应的处理或服务，并将服务结果装配成一个响应包，再沿原路返回到浏览器端(中间服务器连接与浏览器连接件都将消息包进行处理)，最后提交给用户。

- 前面已经提出，浏览器连接件有同步与异步之分，那么它们如何请求与接收信息的程序？请参见下图

  ![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221215017.png)

  

<center>浏览器/服务器的单线程的同步消息通信协作图</center>

![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221215035.png)

<center>浏览器/服务器的多线程服务器连接件的通信协作图</center>

​       上上图描述了简单的浏览器/服务器的同步消息通信的协作图。同步客户构件通过静态绑定与一个单线程服务器构件通信。同步客户构件与一个同步客户连接件相连，单线程服务器构件与一个单线程服务器连接，其中客户连接件与单线程服务器里面都封装着与服务器交互的细节。同步客户连接件主要是整理打包消息后把消息包送给服务器连接件，同时也接收来自服务器的响应消息包，并解包后发给客户浏览器。

　　如果是多线程服务器端则比较复杂些，由于多线程服务器连接件与多线程服务器都是一个复杂的构件。客户可以静态或动态地绑定与它同步或异步的通信。当服务器连接件接收到消息包后就存入消息缓存中，然后由服务器端接收消息包(可以是单线程也可以是多线程)。

　　如果服务器是单线程，就将消息送给单线程服务器构件并等待响应；如果服务器端是多线程，就把消息放入分配器缓存中，再继续处理下一个消息包。当分配器接收到来自缓存的消息后，就逐步地将消息队列分配给空闲的服务器；服务器处理完毕，再打包形成消息响应包，按原路发送回给客户，详细情况请见上图。

　　在上上图中，当同步客户变成异步客户时，同步客户连接件也相应地变成异步客户连接件。它的通信复杂得多，就如同多线程通信比单线程通信复杂一样。主要的不同点是：异步客户连接件在接收响应前还可以处理其他请求。异步客户连接件采用了并行端，客户请求端用来处理输出消息，客户返回端处理输入的响应，响应处理完后存入客户消息输入缓存，供异步客户构件读取。其通信协作图如下图所示。

![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221215250.png)

<center>异步客户连接件的通信协作图</center>

​





