# 事件驱动风格

## 特点

- 系统是由若干子系统或元素所组成的一个整体

- 系统有一定的目标，各子系统在某一种消息机制的控制下，为了这个目标而协调行动

- 在某一种消息机制的控制下，系统作为一个整体与环境相适应和协调

- 在一个系统的若干子系统中，必定有一个子系统起着主导作用，而其他子系统则处于从属地位；

- 任一系统和系统内的任一元素，都有1个事件收集机制和1个事件处理机制，通过这种机制与周围环境发生作用和联系；

- 基于事件驱动的软件系统的示意图

  ![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221165929.png)

  

## 事件驱动风格系统设计时有下述几条基本原则

  - 从系统论的角度来看待描述的对象，合理分解子系统，保证各个子系统的独立性和社会性；
  - 无论系统多么复杂，子系统性质的差异多么大，任何子系统都可以按照有无子系统这一性质分为2类：管理系统和执行系统。
  - 为了达到系统的目标，系统内的各个子系统通过传递消息和执行消息来协同操作。
  - 为了达到系统的目标，系统内的各个子系统通过传递消息和执行消息来协同操作。
  - 在一个完整系统中，必须有这样一个子系统，它没有上级，必须收集系统外的事件及下级发出的事件。
  - 管理类型的子系统一般不执行具体操作，它的主要功能是按照自己的职能指挥下级完成任务，功能性操作一般由执行类型的子系统完成。
  - 在一般情况下，除最高级管理子系统外，子系统一般是“有问才答”，即使在必要的情况下需要积极寻找事件时，也必须征得上级系统得许可，保证了系统的控制流不会分散。

## 事件驱动风格基本结构

  - 事件驱动系统具有某种意义上的递归性，形成了“部分－整体”的层次结构，可以用属性结构加以表示。

  - 一个简单的表示方法是为执行系统定义一些类，另外定义一些类作为这些执行系统的容器类，也就是管理系统。

    

    ![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221170045.png)


## 优点

  - 事件驱动风格非常适合于描述系统族，在属于同一族的任何系统中，系统的高级管理子系统的描述是完全类似的，便于重用；
  - 由于最高管理子系统牢牢的掌握着控制权，又因为各同级子系统一般不直接发生关系，因此容易实现并发处理和多任务操作；
  - 基于事件驱动风格的系统具有良好的可扩展性，设计者只需为某个对象注册一个事件处理接口就可以将该对象引入整个系统，同时并不影响其它的系统对象。
  - 定义了包含执行子系统和管理子系统的类层次结构；
  - 简化客户代码；
  - 使整个系统的设计更具有一般化。

## 缺点

  - 事件驱动风格最大的不足在于构件削弱了自身对系统计算的控制能力
  - 事件驱动风格中存在的另一个问题在于数据共享
  - 系统中各个对象的逻辑关系变得更加复杂

## 事件驱动风格和面向对象风格的关系

  - 基于面向对象风格的系统由多个封装起来的对象构成，对象之间通过消息传递实现通信，而事件驱动正是对消息传递机制的一种实现。
  - 所以基于事件驱动风格的系统往往都是面向对象的。

## 事件驱动风格实例

### 实例1

- Java中的button实现

  ![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221170137.png)

  ```java
  private void  initialize() {  //窗口初始化代码
  …
  //btnPress就是这次点击操作中的事件源
  Buttton  btnPress = new JButton();
  //向事件源btnPress植入侦听器对象ButtonEventHandler
  btnPress.addActionListener (new ButtonEventHandler(this));
   …
  }
  class ButtonEventHandler implements ActionListener {
          //窗体对象
          private EventDemo form = null;
          //通过构造体传入窗体对象，
          //作用在于让侦听器对象明白事件源处于
          //哪个窗体容器中
          public ButtonEventHandler(EventDemo form) {
                       this.form = form;
          }
          //委托方法
          public void actionPerformed(ActionEvent e) {
          //该方法将会把事件的处理权交给窗体容器类的btnPress_Click方法处理。
           this.form.btnPress_Click(e);
          }
     }	
  
    //真正的事件处理代码片断：
    private void btnPress_Click(ActionEvent e) {
       String message = "你点击的按钮名叫:" 
            + ((JButton) e.getSource()).getName();
          this.txtMessage.setText(message);
     }	
  ```

### 实例2

  ```
  
  事件驱动风格实例：JavaBean系统概述
  事件从事件源到监听者的传递是通过对目标监听者对象的Java方法调用进行的。 对每个明确的事件的发生，都相应地定义一个明确的Java方法。这些方法都集中定义在事件监听者（EventListener）接口中，这个接口要继承java.util.EventListener。
  事件状态对象
  与事件发生有关的状态信息一般都封装在一个事件状态对象中，这种对象是java.util.EventObject的子类。按设计习惯，这种事件状态对象类的名应以Event结尾。
  事件监听者接口（EventListener Interface）与事件监听者
  由于Java事件模型是基于方法调用，因而需要一个定义并组织事件操纵方法的方式。JavaBean中，事件操纵方法都被定义在继承了java.util.EventListener类的EventListener接口中，按规定，EventListener接口的命名要以Listener结尾。任何一个类如果想操纵在EventListener接口中定义的方法都必须以实现这个接口方式进行。这个类也就是事件监听者。 
  事件监听者的注册与注销
  为了各种可能的事件监听者把自己注册入合适的事件源中，建立源与事件监听者间的事件流，事件源必须为事件监听者提供注册和注销的方法。在前面的bound属性介绍中已看到了这种使用过程，在实际中，事件监听者的注册和注销要使用标准的设计格式：
  public void add< ListenerType>（< ListenerType> listener）
  public void remove< ListenerType>(< ListenerType> listener)
  
  ```

### 实例3

  ```
  适配类
  适配类是JavaBean事件模型中极其重要的一部分。在一些应用场合，事件从源到监听者之间的传递要通过适配类来“转发”。 
  适配类成为了事件监听者，事件源实际是把适配类作为监听者注册入监听者队列中，而真正的事件响应者并未在监听者队列中，事件响应者应做的动作由适配类决定。 
  
  ```

  

###  实例4

```
Turbo Vision 
Borland公司开发的Turbo Pascal6.0中提供了一种面向对象的事件驱动程序设计的工具包Turbo Vision。Turbo Vision把各种屏幕上的可见对象归纳为2大类：一类为执行对象，另一类为管理对象，分别称为TView和TGroup类对象。又因为TGroup和TView类有相同之处，故TGroup是从TView派生而得，在Turbo Vision中，TGroup类的对象一般不进行实际操作，不直接在屏幕上显示自己，而是通过自己的下属显示自己，所有的实际操作都是通过TView类对象进行的。
    
Turbo Vision 很好地体现了面向对象方法和事件驱动程序设计方法的精髓，TApplication是一个可以运行的交互式程序对象，除了启动和退出之外，它不提供任何功能，使用Turbo Vision，就能高效和快速地开发出高质量地应用程序。 
```

​    Turbo Vision软件包中对象的分类结构如图所示： 

![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221171714.png)

Turbo Vision中对象的分类结构

​    Turbo Vision对象的组装结构一般说来，TApplication对象拥有并管理它创建的3个子对象TMenuBar，TDeskTop和TStatusLine，如图所示. 

![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221171738.png)

Turbo Vision的组装结构



​       在程序的实际运行中，Application对象通常创建各种TWindow类和Tdialog类对象，并委托DeskTop代为管理.因此，DeskTop对象的组装常常随程序的运行而改变.窗口对象(Twindow类)和对话框对象(Toialog类)随应用的不同而不同，典型的窗口和对话框对象的组装结构如图所示.

![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191221171801.png)



窗口和对话框对象的组装结构 

​        Turbo Vision把事件抽象为3种类型的事件:位置事件、聚焦事件和广播事件。典型的位置事件是鼠标器事件，TGroup类视图把位置事件交给管理该区域的子视图;典型的聚焦事件是击键和命令事件(典型的命令事件是由状态行或菜单条、下拉菜单将击键事件或鼠标器事件转换而得)，TGroup类视图把该事件交给处于聚焦状态的下级视图;广播事件是管理视图不知道该交给谁的那种事件，对于这种事件，它将该事件交给所有的视图。

​       Turbo Vision程序在运行时，由TApplication对象收集鼠标器事件和健盘事件以及各种其它事件，然后按一定的规则交给下属去处理.例如，对于鼠标器事件，如果它发生在菜单条上，则将它交给菜单条来处理;如果它发生在状态行，则将它交给状态行来处理;如果它发生在DeskTop上，则将它交给DeskTop来处理。总之，细节问题总是交给下属来处理.状态行和菜单条的任务是将键盘事件和自己辖区的鼠标器事件转换成为命令事件，再上交给TApplication。















