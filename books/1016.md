# 研究新方向

## IEEE 1471标准

基本原则

+ 每个系统具有一个体系结构，但一个体系结构不是一个系统；
+ 体系结构与体系结构描述不是同一件事；
+ 体系结构标准、描述、及开发过程可以不同，并且可以单独地进行研究；
+ 体系结构描述本身是多见解的；
+ 把一个对象的总体概念从其详述中分离开是撰写体系结构标准的一个有效方法。

体系结构定义

+ 体现在各组成部分、它们相互关系及与环境的关系、和指导设计和演变的原理之中的一个系统的基本结构。

组成部分

+ 对关键术语的定义，如体系结构描述、结构性视图与体系结构性视点；
+ 对体系结构与体系结构描述在概念上的分离促进了描述体系结构标准（与蓝图标准相类似）和构筑系统标准（与建筑规范或城市规划法规相类似）的建立；
+ 用于描述一个系统体系结构的内容要求。

体系结构描述要求

+ 一个体系结构描述必须规定系统的用户，确定他们体系结构的要点；
+ 一个体系结构描述必须被编入一个或多个系统的体系结构视图中 ；
+ 一个体系结构描述必须为制定关键的结构性决策提供基本原则 。





##  基于软件体系结构的软件工程

### 基于体系结构的软件开发方法

#### ACPP

以体系结构为中心的软件项目计划

![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20191221133726.png)





#### ABDP

基于软件体系结构的开发过程

​    Perry和Wolf提出在软件设计的早期应该引入构架设计，他们根据软件生命周期各阶段相应的实体、属性、关系、主要产品和评估标准，将软件开发过程分为四个阶段 ：需求分析、体系结构设计、详细设计、实现

![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20191221133710.png)









#### ABC

基于体系结构、面向构件的软件开发方法

北京大学梅宏等研究人员将软件体系结构技术与基于构件的软件开发方法接合，提出了ABC方法 

![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20191221133646.png)







### 基于体系结构的软件组装

![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20191221133628.png)





### 基于体系结构的软件测试方法

+ 体系结构形式化验证
+ 多组态软件体系结构测试

![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20191221133815.png)

> 参与交互的构件是否能达到系统的目标
>
> 系统的完备性和效率
>
> 系统扩展的潜能
>
> 构件接口的一致性
>
> 构件之间连接的机制
>
> 构件行为的顺序
>
> 临界资源的争夺

+ 基于有穷状态进程的形式化验证
+ 基于时态逻辑的形式化验证
+ 基于进程演算的形式化验证
+ 基于Petri网的形式化验证





## 面向服务体系结构

（Service-Oriented Architecture）

### 三位一体的职责构成SOA

![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20191221133946.png)

 SOA应用示例

![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20191221134106.png)

### SOA特性

基于标准的互操作性

> 在SOA当中，接口、通讯协议、工作流、协作和发布都是由一整套国际标准所定义，包括XML, SOAP, WSDL, UDDI, HTTP,CPP, ebXML, bSOA, BPEL, FERA, OWL-S等，从而保证不同平台的系统能够无阻碍的交流

基于发现的动态组装

> 在SOA中的系统所需要的服务均通过运行时发现，运行时加载的方式工作

基于策略的动态管理和总控协作

> SOA的各个服务的运行都由策略（Policy）进行控制，策略的制定、监测、执行都可在运行时内完成。SOA实行总控式协作，即由一个中心控制节点负责控制和调度分布在网络各处的服务



### SOA分类标准

结构（Structure）

> 应用程序的结构是静态(S)还是动态(D)

动态重组能力（Runtime re-composition capability)

> 可以在运行时进行重组(R) 不可以进行重组(N)

容错能力（Fault Tolerant Capability）

> 具有容错的骨干通讯机制(FB)，具有容错的控制服务(FC)，不具有容错能力(FN)

软件工程支持（System Engineering Support）

> 是否具有系统支持的模型监测、数据收集、部署、代码自动生成、策略实施、一致性检查等机制。有用(SY)表示，无用(SN)表示

由此得到一个四元组

> {Structure, Re-composition, Fault-tolerance, System-engineering}对各种SOA进行分类

SOA类别及其进化

![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20191221134421.png)



 

### Customer Centric SOA

常规SOA模式

> 服务提供者向服务代理注册开发出来的服务，由应用程序构建者来寻找需要的服务

CCSOA模式

> 在传统SOA的基础上，应用程序构建者也可以发布应用程序模板，服务提供者可以根据模板的需要开发新的服务



![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20191221134624.png)

```
上图的步骤为：
1应用程序构建者编写应用程序模版，模板内包含工作流信息、需要服务规格信息等
2应用程序模版在服务代理的库中进行注册并发布
3一个订阅了应用程序模版库的服务提供者收到有新模版到达的通知，于是查询这个新模版
4本体和分类技术可以辅助进行被提供模版和目标模版之间的自动匹配
5在查询中，服务代理返回给服务提供者关于应用程序模版的详细信息
6服务提供者依据模版开发新的服务，并提交到服务代理。服务代理依据模版中的信息对新服务进行校验和评估
7一旦评估通过，服务代理通知应用程序构建者有可用的新服务
8应用程序构建者评估和测试新的服务
9一旦通过测试，应用程序构建者就将应用程序模版和新服务绑定，生成可以运行的应用系统
```



### 商业SOA平台

IBM基于WebShpere的SOA Foundation Architecture

![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20191221134724.png)







## 柔性软件体系结构

> 柔性软件体系结构是指可以根据需求的变化而容易发生形态变化的体系结构 

### 柔性软件体系结构的行为

> 添加新的构件
>
> 升级已存在构件
>
> 删除不需要的构件
>
> 动态改变构件之间的关系
>
> 动态改变构件到执行平台的映射

### 柔性软件体系结构的应用领域

![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20191221134940.png)



### 自适应的柔性软件体系结构

自适应软件体系结构是根据操作环境的变化而变化的体系结构

> 外界的变化包括用户输入、硬件设备输入、传感器信号、以及程序指令等

自适应软件体系结构需要解决的问题

> 在什么条件下系统发生改变
>
> 自适应软件体系结构应具有开放性质还是封闭性质
>
> 需要实现什么样的自适应程度
>
> 如何演算从而评估变化后带来的收益是否大于变化本身的成本
>
> 变化的频繁程度如何
>
> 自适应变化需要的原始信息有哪些

自适应的基本结构

> Monitor监控外界的变化
>
> Adapt负责调整系统模型
>
> Control负责将外界变化演算出模型变化，并作出变化决策

![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20191221135107.png)

移动环境的自适应柔性软件体系结构

> 为何移动环境需要动态自适应
>
> 移动环境下设备往往需要连续工作，对自身进行改变必须在运行时下进行
>
> 移动设备经受的操作环境的改变与固定的计算设备相比要频繁的多
>
> 使用移动设备的用户的需求也在不断改变

自适应体系结构示例：Rainbow

![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20191221135143.png)



 

### 移动环境下的软件体系结构

#### 移动环境应用实例

- 

  ![img](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20200115191852.png)

#### 为何使用体系结构的方法

+ 基于编程语言的方法
> 使用条件表达式
> 使用参数
> 使用异常
+ 缺点
> 将软件行为和自行应的过程混杂起来
> 当引入新的适应机制式时需要修改大量代码，造成扩展性底下
+ 结论
> 采用移动中间件来具体负责适应行为

#### 移动中间件

- 移动中间件特点

  - > 足够轻量使其可以运行在资源受限的手持设备上

  - > 支持异步通讯，使移动设备可以用较短时间周期性访问网络，用以节省能源

  - > 可以感知环境的变化、例如自身状态、位置、可以获得的服务等

  - > 移动中间件所作出的推理必须简单有效，即推理得到的改变决策必须使系统有较大的收益

- 移动中间件

  - > 中间件可以为解决分布是系统的基本通讯和管理问题，使开发者专注于业务流程

  - > 在移动环境下，动态服务和位置发现，从而动态的调整体系结构的形态是移动中间件的核心思想

    ![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20191221135730.png)

- 移动中间件实例MADAM

  ![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20191221135759.png)

  ![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20191221135836.jpg)

  

- 移动中间件的运行方式——可变属性

  ![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20191221135856.png)

  

- 绑定属性实例

  ![](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20191221135922.png)

#### 移动柔性软件体系结构的发展

+ 统一的、通用的体系结构模型和环境模型表示方法

> 如何更好的描述体系结构模型这个变化的基础

> 如何更好的描述环境模型这个变化的触发点

+ 变化决策推理算法的设计范式

> 如何设计才能使推理算法可以在资源受限的设备上流畅运行，并保证其结果的有效性

用户干涉对推理算法的影响

> 例如调整某些属性的计算权重

### 自修复系统

- 自修修复系统的分类

   

  基于软件体系结构的自修复系统使用软件体系结构模型为基础进行自修复，是外修复系统的一种

  - 内部修复
    - 修复代码和常规代码集成到普通代码当中
  - 外部修复
    - 修复代码单独作为一个构件存在于系统当中，与普通的代码互相隔离

- 自修复系统设计过程

  - 体系结构设计

    - 将系统分为两部分

      - 体系结构管理器（AMR）和体系结构模型容器（AMC）

      - 运行时环境（RE）和实际运行系统（RS）

      - 图示

        - 

          ![img](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20200115191853.png)

  - 修复行为触发

    - 运行时环境负责监控运行时系统的各个参数，并将数据发送给体系结构管理器
      - 延迟信息
      - 内存消耗
      - CPU占用
      - 负载
      - 系统异常
      - 用户指令

  - 修复行为

    - 体系结构管理器负责分析收集的数据，并执行和校验体系结构的重新配置，并将决策的目标体系结构模型映射成运行时环境可以接受的操作集
    - 运行时环境对运行系统执行实际的修复操作

- 体系结构管理器结构

  - 

    ![img](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20200115191854.png)

### 支持代码移动的体系结构

- 代码移动

  - 定义

    - 可以动态改变代码和代码所在位置绑定的能力

  - 优点

    - 在需要传输大量数据的情况下，传输执行代码可能会更为快捷
    - 使得代码具有自我决策的能力，在网络中自行传输

  - 图示

    - 

      ![img](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20200115191855.png)

- 支持代码移动的基本结构

  - 

    ![img](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20200115191856.png)

- 支持代码移动的运行环境结构

  - 

    ![img](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20200115191857.png)



## 动态软件体系结构的描述

-  SA通常是对系统的静态描述,如果需要改变体系结构则必须重新设计新的SA,这已不能适应现在越来越多的需要在运行时刻发生变化的系统的设计需求.则允许系统在执行过程中修改其体系结构,修改过程通常也被称为运行时刻的演化(即在线演化)或动态性。

- 主要的变化体现在以下几个方面：

  - 结构
    - 软件系统为适应当前的计算环境往往需要调整自身的结构,比如增加或删除构件、连接子,这将导致SA的拓扑结构发生显式的变化
  - 行为
    - 由于用户需求的变化或者系统自身QoS调节的需要,软件系统在运行过程中会改变其行为,比如由于安全级别的提高更换加密算法;将http协议改为https协议,行为的变化往往是由构件或连接子的替换和重配置引起的
  - 属性
    - 已有的ADL大都支持对非功能属性(non functional properties)的规约和分析,比如对服务响应时间和吞吐量的要求等,在系统运行的过程中这些要求可能发生改变,而这些变化又会进一步触发软件系统结构或行为的调整.属性的变化是驱动系统演化的主要原因
  - 风格
    - 系统由一种体系结构风格演化成“衍生”的另外一种风格。
    - 例如两层C/S结构衍生成多层C/S结构，或者衍生成B/S结构

- 动态体系结构描述的约束

  - 一致性
    - 体系结构规约与系统实现的一致性,运行时刻的修改应及时地反映到规约中,以保证规约不会过时
    - 系统内部状态的一致性,正在修改的部分不应被其他用户或模块更改
    - 系统行为的一致性,若“管道-过滤器”风格的结构中增加一个过滤器,则需要保证该过滤器的输入和输出与相连的管道的要求一致
    - 体系结构风格的一致性,演化前后体系结构或者保持风格不变,或者演化为当前风格的“衍生”风格
  - 完整性
    - 系统的演化不能破坏SA规约中的约束
    - 演化前后系统的状态不会丢失,否则系统将变得不“安全”,甚至不能正确运行.
  - 追溯性
    - 传统的ADL采用逐步精化的方式将一个抽象层次很高的ADL规约逐步精化为具体的可直接实现的ADL规约，在精化的过程中通过形式化的验证保证每一步精化都符合要求,满足可追溯性。
    - 对于动态系统而言，追溯性除了需要满足静态设和净化阶段被满足，还需要被延伸到运行时刻，以保证系统的任何一次修改都会被验证，这样既有利于软件的维护，也为软件的进一步演化提供了可分析的依据。

- 动态体系结构描述语言D-ADL

  - 将构件行为进行分类

    - 计算行为：计算行为和动态行为.计算行为面向系统的商业逻辑,处理业务功能中的数据信息
    - 动态行为：面向系统的预定义演化逻辑,使系统能够自适应演化,以体系结构元素为处理对象,如增删构件、建立新的连接等.

  - 基于高阶π演算

    - 所有描述行为都可在高阶π演算中找到对应表示
    - 具有强有力的形式化基础，可以对软件体系结构行为作深入的推理和规约

  - 对高阶π演算进行扩充

    - 对于某些不能使用高阶π演算方便表示的概念（间接可以表示）进行了扩充
    - 提供了构件动态行为new、attach和detach的语法概念

  - 图示

    - 

      ![img](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20200115191858.png)

  - 动态体系结构描述语言D-ADL（续）

    - 

      ![img](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20200115191859.png)

      ![img](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20200115191900.png)

- 体系结构动态演化系统的设计

  - 反射

    - 反射(reflect)是指计算系统通过与自身状态和行为具有因果互联的系统自述，以描述、推理和操纵自身的能力

    - 可以将体系结构包含在系统当中作为元数据，并对外提供访问接口，以实现对系统的体系结构进行运行时控制

    - 图示

      - 

        ![img](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20200115191901.png)

  - 体系结构在线演化的实施

    - 预设演化
      在设计时就定义好的演化，以演化规则库的形式存储
    - 非预设演化
      未预设演化需以基本访问接口为基础在运行时动态生成

  - 体系结构在线演化的校验

    - 使用类型系统检测一致性
      - 将体系结构风格衍生路线设计为继承的类型体系，体系结构演化只能沿着继承路线向子类型前进
      - 将构件接口类型化，在改变构件连接关系时要保证新的连接的类型一致
    - 使用事务处理机制确保演化不被恶性中断
      - 每次演化的一些列操作都在一个事务当中进行
      - 演化发生错误时全部操作回滚
      - 在分布式系统当中，事务可保证在线演化操作的在并行访问的情况下的正确性

- 连接器

  - 连接器的形式化重用

    - 通过重用旧有的、相对简单的连接器来得到新的、较为复杂的连接器，就可以获得一种增量式的连接器开发方法，从而提高软件开发的质量和效率
    - 具有形式化基础（例如使用CSP）使得新的连接器定义可以进行形式化检测

  - 连接器组合元操作

    - 角色（Role）元操作
      - Substitute:角色的替代
        - 可以实现用一个角色来充当另一个已经定义的角色
      - ConcurrencyMerge:角色的并行合一
        - 可以实现用一个角色来同时充当多个已经定义的角色，并且它“扮演”的多个角色之间应并行协调
      - AlternativeMerge:角色的选择合一
        - 可以实现用一个角色来完成多个已经定义的角色的功能，并且在每一次完整的交互中该角色只能充当其中的某一个角色
      - Choice:该操作将两个或者多个粘结进程选择地组合起来
        - 这种选择可能是上述的不确定性选择，也可能是确定的选择，即选择权在其所在环境的选择。
        - 如果它所规范的角色在某次完整的交互中想要参与的初始事件仅被某个子粘结进程所允许，那么组合粘结进程就选择该子粘结进程去承担该次交互的协调任务;否则，如果角色想要参与的初始事件为多个子粘结进程所允许，那么它就会任意选择其中的某个子粘结进程去承担此次交互的协调任务。 
      - Interleave:该操作将两个或者多个粘结进程交错地组合起来
        - 如果用这种组合得到的粘结进程去协调和约束某个角色的行为，那么该角色无论何时要想参与某一个事件，只需得到某个子粘结进程的允许即可。
        - 当然，如果此时有多个子粘结进程都允许该事件发生，那么组合粘结进程就会任意选择其中的某个子粘结进程去承担允许该事件发生的责任。 
    - 粘连（Glue）元操作
      - Parallel:该操作将两个或者多个粘结进程并行地组合起来
        - 如果用这种组合得到的粘结进程去规范某个角色行为，那么该角色无论何时要想参与某一个事件，都必须得到各个子粘结进程的共同允许。
      - Decision:该操作将两个或者多个粘结进程不确定性选择地组合起来
        - 这里的不确定性选择指的是:组合得到的粘结进程究竟选择哪一个子粘结进程去规范角色的某一次完整的交互行为，由其自身来决定。
      - Follow:该操作将两个或者多个粘结进程顺序地组合起来
        - 用这种组合得到的粘结进程依次用其子粘结进程去协调和约束其所规范的角色的行为，当然，后续的子粘结进程要想承担这种责任，必须满足前行的子粘结进程能够成功终止。
      - Interrupt:该操作将两个或者多个粘结进程顺序中断地组合起来
        - 用这种组合得到的粘结进程可以随着后续子粘结进程初始事件的发生，用后续的子粘结进程去中断和接替前行的子粘结进程，并获得协调和约束角色的责任。
      - Lightning:该操作可以看作是Interrupt的一种特殊情形，它将两个粘结进程顺序中断地组合起来
        - 但与Interrupt不同的是，前行子粘结进程被中断并不取决于后续子粘结进程初始事件的发生，而是某个被定义的中断事件。
        - 为了表示这个特殊事件，我们把它作为第3个参数引入到Lightning函数中。

  - 连接器组合示例

    - 

      ![img](https://cdn.jsdelivr.net/gh/ZanderZhao/img20/file/20200115191902.png)

  - 连接器组合法性检测

    - 检查1：连接器的每个角色都是无死锁的
      - 这是对连接器角色内部相容性的检测。
      - 由于组合连接器的每个角色是在重用已有连接器的角色基础上得到的，因此，这种检查可以分为两种情形:若组合连接器的某个角色是通过替换或者选择合一得到的，那么对子连接器相应角色的检查结果仍然适用于组合连接器的这一角色；若组合连接器的某个角色是通过并行合一得到的，那么就必须重新检查。
      - 因为对于一个并行合一的角色进程，可能会出现这样的问题:在某个时候，虽然它的子角色都各自能参与某些事件，但它却不能参与任何一个事件。
    - 检查2：连接器是无死锁的
      - 这种相容性的检查是对连接器整体的检查。
      - 因此，检查1如果通不过，也会反映到检查2中。
      - 角色规范了充当其实例的组件预期要发生的行为，而粘结规范的是对这些行为的协调与约束。
      - 角色规范与粘结规范是否会出现矛盾，就需要用检查2来考察。